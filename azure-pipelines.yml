trigger:
- main

pool:
  vmImage: 'ubuntu-latest'

variables:
  buildConfiguration: 'Release'
  terraformVersion: '1.5.7'
 -group: UserManagement-Secrets

stages:
- stage: Test
  displayName: 'Run Tests'
  jobs:
  - job: RunTests
    displayName: 'Unit Tests'
    steps:
    - task: UseDotNet@2
      displayName: 'Use .NET SDK'
      inputs:
        packageType: 'sdk'
        version: '9.x'
        
    - task: DotNetCoreCLI@2
      displayName: 'Restore and Build'
      inputs:
        command: 'build'
        projects: '**/*.csproj'
        arguments: '--configuration $(buildConfiguration)'
        
    - task: DotNetCoreCLI@2
      displayName: 'Run Unit Tests'
      inputs:
        command: 'test'
        projects: '**/*Tests.csproj'
        arguments: '--configuration $(buildConfiguration) --logger trx'
        
    - task: PublishTestResults@2
      displayName: 'Publish Test Results'
      inputs:
        testResultsFormat: 'VSTest'
        testResultsFiles: '**/*.trx'

- stage: Infrastructure
  displayName: 'Deploy Infrastructure'
  dependsOn: Test
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  - job: TerraformDeploy
    displayName: 'Terraform Deploy'
    steps:
    - task: TerraformInstaller@0
      displayName: 'Install Terraform'
      inputs:
        terraformVersion: '$(terraformVersion)'
    
    - task: TerraformTaskV4@4
      displayName: 'Terraform Init'
      inputs:
        provider: 'azurerm'
        command: 'init'
        workingDirectory: 'terraform/'
        backendServiceArm: 'AzureServiceConnection'
        backendAzureRmResourceGroupName: 'rg-user-management-api'
        backendAzureRmStorageAccountName: 'tfstate112715'
        backendAzureRmContainerName: 'tfstate'
        backendAzureRmKey: 'terraform.tfstate'
    
    - task: TerraformTaskV4@4
      displayName: 'Terraform Plan'
      inputs:
        provider: 'azurerm'
        command: 'plan'
        workingDirectory: 'terraform/'
        environmentServiceNameAzureRM: 'AzureServiceConnection'
        commandOptions: '-var="db_admin_password=$(DB_ADMIN_PASSWORD)" -var="jwt_secret_key=$(JWT_SECRET_KEY)"'
    
    - task: TerraformTaskV4@4
      displayName: 'Terraform Apply'
      inputs:
        provider: 'azurerm'
        command: 'apply'
        workingDirectory: 'terraform/'
        environmentServiceNameAzureRM: 'AzureServiceConnection'
        commandOptions: '-var="db_admin_password=$(DB_ADMIN_PASSWORD)" -var="jwt_secret_key=$(JWT_SECRET_KEY)" -auto-approve'
    
    - task: TerraformTaskV4@4
      displayName: 'Get Terraform Outputs'
      inputs:
        provider: 'azurerm'
        command: 'output'
        workingDirectory: 'terraform/'
        environmentServiceNameAzureRM: 'AzureServiceConnection'
        commandOptions: '-json'
      name: 'TerraformOutputs'
    
    - task: PowerShell@2
      displayName: 'Set Pipeline Variables from Terraform'
      inputs:
        targetType: 'inline'
        script: |
          # Parse Terraform outputs
          $terraformOutputs = Get-Content "$(TerraformOutputs.jsonOutputVariablesPath)" | ConvertFrom-Json
          
          # Set pipeline variables
          $resourceGroupName = $terraformOutputs.resource_group_name.value
          $apiUrl = $terraformOutputs.api_url.value
          
          Write-Host "Resource Group: $resourceGroupName"
          Write-Host "API URL: $apiUrl"
          
          # Set variables for next stage
          Write-Host "##vso[task.setvariable variable=RESOURCE_GROUP_NAME;isOutput=true]$resourceGroupName"
          Write-Host "##vso[task.setvariable variable=API_URL;isOutput=true]$apiUrl"
      name: 'setVars'

- stage: Deploy
  displayName: 'Deploy Application'
  dependsOn: Infrastructure
  condition: succeeded()
  variables:
    RESOURCE_GROUP_NAME: $[ stageDependencies.Infrastructure.TerraformDeploy.outputs['setVars.RESOURCE_GROUP_NAME'] ]
    API_URL: $[ stageDependencies.Infrastructure.TerraformDeploy.outputs['setVars.API_URL'] ]
  jobs:
  - deployment: DeployToAzure
    displayName: 'Deploy to Container Instance'
    environment: 'production'
    strategy:
      runOnce:
        deploy:
          steps:
          - task: AzureCLI@2
            displayName: 'Restart Container Instance'
            inputs:
              azureSubscription: 'AzureServiceConnection'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Restarting container in resource group: $(RESOURCE_GROUP_NAME)"
                
                # Check if container exists
                if az container show --resource-group $(RESOURCE_GROUP_NAME) --name user-management-api > /dev/null 2>&1; then
                  echo "Container found. Restarting..."
                  
                  # Restart the container
                  az container restart \
                    --resource-group $(RESOURCE_GROUP_NAME) \
                    --name user-management-api
                  
                  echo "Waiting for container to be ready..."
                  sleep 30
                  
                  # Verify deployment
                  CONTAINER_STATE=$(az container show \
                    --resource-group $(RESOURCE_GROUP_NAME) \
                    --name user-management-api \
                    --query "instanceView.state" \
                    --output tsv)
                  
                  if [ "$CONTAINER_STATE" = "Running" ]; then
                    echo "Container is running successfully"
                    echo "API URL: $(API_URL)"
                    echo "Swagger: $(API_URL)/swagger"
                  else
                    echo "Container state: $CONTAINER_STATE"
                    echo "Container may still be starting up"
                  fi
                else
                  echo "Container not found. It may need to be created by Terraform first."
                  echo "Expected container name: user-management-api"
                  echo "Resource group: $(RESOURCE_GROUP_NAME)"
                fi

          - task: AzureCLI@2
            displayName: 'Health Check'
            inputs:
              azureSubscription: 'AzureServiceConnection'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Performing health check on: $(API_URL)"
                
                # Wait a bit more for the API to be ready
                sleep 10
                
                # Try health check with retry
                for i in {1..5}; do
                  echo "Health check attempt $i/5"
                  
                  HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$(API_URL)" || echo "000")
                  
                  if [ "$HTTP_STATUS" = "200" ]; then
                    echo "Health check passed!"
                    break
                  else
                    echo "Health check failed with status: $HTTP_STATUS"
                    if [ $i -eq 5 ]; then
                      echo "All health check attempts failed"
                    else
                      echo "Retrying in 10 seconds..."
                      sleep 10
                    fi
                  fi
                done
                
                echo "Deployment process completed"
                echo "API URL: $(API_URL)"
                echo "Swagger documentation: $(API_URL)/swagger"