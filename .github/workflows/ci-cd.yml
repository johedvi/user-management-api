name: User Management API - CI/CD

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

permissions:
  contents: read
  checks: write
  pull-requests: write

env:
  BUILD_CONFIGURATION: 'Release'
  TERRAFORM_VERSION: '1.5.7'
  DOTNET_VERSION: '9.x'

jobs:
  test:
    name: 'Run Tests'
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
        
    - name: Restore dependencies
      run: dotnet restore
      
    - name: Build
      run: dotnet build --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore
      
    - name: Run tests
      run: dotnet test --configuration ${{ env.BUILD_CONFIGURATION }} --no-build --logger trx --results-directory ./test-results
      
    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results
        path: test-results/*.trx

  infrastructure:
    name: 'Deploy Infrastructure'
    runs-on: ubuntu-latest
    needs: test
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    outputs:
      resource_group_name: ${{ steps.terraform_output.outputs.resource_group_name }}
      api_url: ${{ steps.terraform_output.outputs.api_url }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}
        terraform_wrapper: false
        
    - name: Terraform Init
      working-directory: terraform
      run: |
        terraform init \
          -backend-config="resource_group_name=rg-user-management-api" \
          -backend-config="storage_account_name=tfstate112715" \
          -backend-config="container_name=tfstate" \
          -backend-config="key=terraform.tfstate"
      env:
        ARM_CLIENT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }}
        ARM_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
        ARM_SUBSCRIPTION_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}
        ARM_TENANT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenantId }}
        
    - name: Terraform Plan
      working-directory: terraform
      run: |
        terraform plan \
          -var="db_admin_password=${{ secrets.DB_ADMIN_PASSWORD }}" \
          -var="jwt_secret_key=${{ secrets.JWT_SECRET_KEY }}"
      env:
        ARM_CLIENT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }}
        ARM_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
        ARM_SUBSCRIPTION_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}
        ARM_TENANT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenantId }}
        
    - name: Terraform Apply
      working-directory: terraform
      run: |
        terraform apply -auto-approve \
          -var="db_admin_password=${{ secrets.DB_ADMIN_PASSWORD }}" \
          -var="jwt_secret_key=${{ secrets.JWT_SECRET_KEY }}"
      env:
        ARM_CLIENT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }}
        ARM_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
        ARM_SUBSCRIPTION_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}
        ARM_TENANT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenantId }}
        
    - name: Get Terraform Outputs
      id: terraform_output
      working-directory: terraform
      run: |
        RESOURCE_GROUP_NAME=$(terraform output -raw resource_group_name)
        API_URL=$(terraform output -raw api_url)
        
        echo "resource_group_name=$RESOURCE_GROUP_NAME" >> $GITHUB_OUTPUT
        echo "api_url=$API_URL" >> $GITHUB_OUTPUT
        
        echo "Resource Group: $RESOURCE_GROUP_NAME"
        echo "API URL: $API_URL"
      env:
        ARM_CLIENT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }}
        ARM_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
        ARM_SUBSCRIPTION_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}
        ARM_TENANT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenantId }}

  deploy:
    name: 'Deploy Application'
    runs-on: ubuntu-latest
    needs: infrastructure
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        
    - name: Restart Container Instance
      run: |
        RESOURCE_GROUP_NAME="${{ needs.infrastructure.outputs.resource_group_name }}"
        API_URL="${{ needs.infrastructure.outputs.api_url }}"
        
        echo "Restarting container in resource group: $RESOURCE_GROUP_NAME"
        
        # Check if container exists
        if az container show --resource-group "$RESOURCE_GROUP_NAME" --name user-management-api > /dev/null 2>&1; then
          echo "Container found. Restarting..."
          
          # Restart the container
          az container restart \
            --resource-group "$RESOURCE_GROUP_NAME" \
            --name user-management-api
          
          echo "Waiting for container to be ready..."
          sleep 30
          
          # Verify deployment
          CONTAINER_STATE=$(az container show \
            --resource-group "$RESOURCE_GROUP_NAME" \
            --name user-management-api \
            --query "instanceView.state" \
            --output tsv)
          
          if [ "$CONTAINER_STATE" = "Running" ]; then
            echo "Container is running successfully"
            echo "API URL: $API_URL"
            echo "Swagger: $API_URL/swagger/index.html"
          else
            echo "Container state: $CONTAINER_STATE"
            echo "Container may still be starting up"
          fi
        else
          echo "Container not found. It may need to be created by Terraform first."
          echo "Expected container name: user-management-api"
          echo "Resource group: $RESOURCE_GROUP_NAME"
        fi
        
    - name: Health Check
      run: |
        API_URL="${{ needs.infrastructure.outputs.api_url }}"
        HEALTH_CHECK_URL="$API_URL/swagger/index.html"
        echo "Performing health check on: $HEALTH_CHECK_URL"
        
        # Wait longer for the API to be ready after container restart
        sleep 60
        
        # Try health check with retry
        for i in {1..5}; do
          echo "Health check attempt $i/5"
          
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$HEALTH_CHECK_URL" || echo "000")
          
          if [ "$HTTP_STATUS" = "200" ]; then
            echo "Health check passed!"
            break
          else
            echo "Health check failed with status: $HTTP_STATUS"
            echo "Checking URL: $HEALTH_CHECK_URL"
            if [ $i -eq 5 ]; then
              echo "All health check attempts failed"
            else
              echo "Retrying in 15 seconds..."
              sleep 15
            fi
          fi
        done
        
        echo "Deployment process completed"
        echo "API URL: $API_URL"
        echo "Swagger documentation: $API_URL/swagger/index.html"

  deploy-frontend:
    name: 'Deploy Frontend'
    runs-on: ubuntu-latest
    needs: [infrastructure, deploy]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json
        
    - name: Install dependencies
      run: |
        cd frontend
        npm ci
        
    - name: Build frontend
      run: |
        cd frontend
        npm run build
      env:
        VITE_API_URL: ${{ needs.infrastructure.outputs.api_url }}
        
    - name: Deploy to Azure Static Web Apps
      uses: Azure/static-web-apps-deploy@v1
      with:
        azure_static_web_apps_api_token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN }}
        repo_token: ${{ secrets.GITHUB_TOKEN }}
        action: "upload"
        app_location: "frontend"
        output_location: "dist"